Clean Code Serie : Function

1- Small
	Function should be Small (If possible 3-4 lines of code).
	
2- Block & Indent
	Block inside "if, else, while..." statements should be one line => call to a function(Cause function have clear descriptive name).
	Max Indent level for a function should be 2 (this make the function more readable)
	
3- Do One Thing : Function should do one thing, They should do it well, They should do it only.
	To know if a function is doing "one thing", just look at it level of abstraction (if it has multiple level => the function is clearly doing more than one (max = 2) thing).
	Another way to know if a function is doing "more than one thing" is to try to extract another function from it 
	(if that new function name is not restatement of the first one ==> your function where doing "more than one thing").
	
	-- Becareful of Sections within "Function"
		If your function divided into 3 sections like "declaration, initial, execution..", this clearly mean that your function is doing "more than one thing".
		Corolaire : Function doing one thing can't reasonably be divided into section.
		
	-- One Level Of Abstraction Per Function
		In order to make sure that our function is doing one thing is to make sure it has one level of abstraction.
		Function having multiple level of abstraction is confusing
		
	-- Reading Code from Top to Bottom : "The Stepdown Rule" *** This rule is the key to keep function short & doing one thing ***
		Functions may be followed by those at the next level of abstraction.
		"This Rule can be learnt by describing the program as a set of 'TO' paragraphs," 
		"each 'TO' describe the current level of abstraction and lead to subsequent 'TO' paragraph at the next level down" 
		Example : 
			=> To include the setups and teardowns, we include setups, then we include the test page content,
				and then we include the teardowns.
				=> To include the setups, we include the suite setup if this is a suite, then we include the
					regular setup.
				=> To include the suite setup, we search the parent hierarchy for the “SuiteSetUp” page
					and add an include statement with the path of that page.
				=> To search the parent. . .
	
	-- Dealing with Switch Statement
		Those statement are always large ==> it's hard make a switch statement that do "only one thing"'.
		***==> But it's possible to burried Switch statement' in a low level class and make sure it never repeated again => Polymorphism
		Example : "Employee pay from Employee type"
		
		public Money calculatePay(Employee e) throws InvalidEmployeeType {
			switch (e.type) {
				case COMMISSIONED:
					return calculateCommissionedPay(e);
				case HOURLY:
					return calculateHourlyPay(e);
				case SALARIED:
					return calculateSalariedPay(e);
				default:
					throw new InvalidEmployeeType(e.type);
			}
		}
		
		Problem with this function :
			1) It's large & Every time new Employee type is added => It will grow (So it's clear that it's doing more than one thing).
			2) It violates the SRP (Single Responsabilitie Principle) => cause there more than one reason for this function to change.
			3) It violates the OCP (Open Close Principle) => it will change every time a new employe type is added.
		
		Solution : is to burry the "switch statement in the basement of an 'Abstract Factory'"
		
			public abstract class Employee {
				public abstract boolean isPayday();
				public abstract Money calculatePay();
				public abstract void deliverPay(Money pay);
			}
			-----------------
			public interface EmployeeFactory {
				public Employee makeEmployee(EmployeeRecord r) throws InvalidEmployeeType;
			}
			-----------------
			public class EmployeeFactoryImpl implements EmployeeFactory {
				public Employee makeEmployee(EmployeeRecord r) throws InvalidEmployeeType {
					switch (r.type) {
						case COMMISSIONED:
							return new CommissionedEmployee(r) ;
						case HOURLY:
							return new HourlyEmployee(r);
						case SALARIED:
							return new SalariedEmploye(r);
						default:
							throw new InvalidEmployeeType(r.type);
					}
				}
			}
		
		NB : Switch Statement is tolerate if it's used only once.
		
4- Use Descriptive Names
	Function name must be the best to describe what the function does.
	Naming functions well result to a Rule known as Ward's Rule => '*** You know that you're working on clean code if every function turn to do what you expected it to do ***'
	*** The Key for good name is : The smaller & 'does one thing' a function is, the easier it is to give it a better name. ***
	Don't forget that a '"long descriptive name" is better than a "short enigmatic name".
	"Be Consistent with your Names" : for example if you use "getAll" in some module, don't' use for example 'findAll, fetchAll' in other module; you have to be consistent and stay with your first Name.
	
5- Function Arguments :
	
		
		
			

	
	
	